import psycopg2
import os
import time
import platform
import random
from typing import Optional, Dict, Any, List, Tuple

class LordOfTheRingsMUD:
    def __init__(self):
        self.connection = None
        self.current_player_id = None
        self.current_scenario_id = None
        self.player_alive = True
        
    def clear_screen(self):
        """Limpa o terminal baseado no sistema operacional"""
        if platform.system() == "Windows":
            os.system('cls')
        else:
            os.system('clear')
    
    def pause_and_clear(self, message: str = "‚è∏Ô∏è Pressione Enter para continuar..."):
        """Pausa, aguarda Enter e limpa a tela"""
        input(f"\n{message}")
        self.clear_screen()
        
    def connect_database(self):
        """Conecta ao banco de dados PostgreSQL"""
        try:
            self.connection = psycopg2.connect(
                host="localhost",
                database="senhor_dos_aneis",
                user="lord", 
                password="12345",
                port="5432"
            )
            print("‚úÖ Conex√£o com banco de dados estabelecida!")
            return True
        except Exception as e:
            print(f"‚ùå Erro ao conectar com o banco: {e}")
            print("üîß Verifique se o PostgreSQL est√° rodando e as credenciais est√£o corretas.")
            return False

    def setup_quest_system(self):
        """Configura o sistema de quests corrigido usando apenas tabelas existentes"""
        try:
            cursor = self.connection.cursor()
            
            # Verificar se as tabelas de quest j√° existem
            cursor.execute("""
                SELECT EXISTS (
                    SELECT FROM information_schema.tables 
                    WHERE table_schema = 'public' AND table_name = 'quest'
                );
            """)
            
            quest_exists = cursor.fetchone()[0]
            
            if not quest_exists:
                print("üîß Configurando sistema de quests...")
                
                # Criar tabela de quest
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS quest (
                        id_quest SERIAL PRIMARY KEY,
                        nome VARCHAR(100) NOT NULL,
                        descricao TEXT NOT NULL,
                        recompensa_xp INTEGER DEFAULT 0,
                        recompensa_item VARCHAR(100),
                        pre_requisito_level INTEGER DEFAULT 1,
                        tipo_quest VARCHAR(50) DEFAULT 'Principal',
                        status VARCHAR(20) DEFAULT 'Dispon√≠vel'
                    );
                """)
                
                # Criar tabela de progresso
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS quest_progresso (
                        id_progresso SERIAL PRIMARY KEY,
                        id_jogador INTEGER NOT NULL,
                        id_quest INTEGER NOT NULL,
                        progresso_atual INTEGER DEFAULT 0,
                        progresso_maximo INTEGER NOT NULL,
                        status VARCHAR(20) DEFAULT 'Em Progresso',
                        iniciado_em TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (id_jogador) REFERENCES personagem(ID_personagem),
                        FOREIGN KEY (id_quest) REFERENCES quest(id_quest),
                        UNIQUE(id_jogador, id_quest)
                    );
                """)
                
                # Inserir quests corrigidas apenas se n√£o existirem
                cursor.execute("""
                    INSERT INTO quest (nome, descricao, recompensa_xp, recompensa_item, pre_requisito_level, tipo_quest) 
                    SELECT * FROM (VALUES
                        ('A Jornada Come√ßa', 'Fale com 2 NPCs diferentes para aprender sobre a Terra M√©dia', 100, 'Po√ß√£o de Cura', 1, 'Principal'),
                        ('Defensor das Terras', 'Derrote 3 criaturas para proteger os inocentes', 200, 'Espada de Ferro', 1, 'Principal'),
                        ('Explorador Iniciante', 'Visite todos os 4 cen√°rios diferentes', 150, 'Mapa √âlfico', 1, 'Secund√°ria'),
                        ('Comerciante Amig√°vel', 'Realize 2 transa√ß√µes comerciais', 75, 'Bolsa de Moedas', 1, 'Secund√°ria'),
                        ('O Palant√≠r Perdido', 'Encontre os tr√™s fragmentos do Palant√≠r perdido espalhados pela Terra M√©dia', 500, 'Palant√≠r Restaurado', 1, '√âpica')
                    ) AS v(nome, descricao, recompensa_xp, recompensa_item, pre_requisito_level, tipo_quest)
                    WHERE NOT EXISTS (
                        SELECT 1 FROM quest WHERE quest.nome = v.nome
                    )
                """)
                
                self.connection.commit()
                print("‚úÖ Sistema de quests configurado!")
            
            cursor.close()
            
        except Exception as e:
            print(f"‚ùå Erro ao configurar sistema de quests: {e}")
            self.connection.rollback()

    def get_available_classes(self) -> List[Dict[str, str]]:
        """Busca as classes dispon√≠veis no banco de dados"""
        try:
            cursor = self.connection.cursor()
            
            cursor.execute("""
                SELECT table_name FROM information_schema.tables 
                WHERE table_schema = 'public' 
                AND table_name IN ('guerreiro', 'mago', 'arqueiro', 'sacerdote')
                ORDER BY table_name
            """)
            
            classes = []
            class_descriptions = {
                'arqueiro': {'name': 'Arqueiro', 'emoji': 'üèπ', 'desc': 'Preciso com ataques √† dist√¢ncia'},
                'guerreiro': {'name': 'Guerreiro', 'emoji': '‚öîÔ∏è', 'desc': 'Especialista em combate corpo a corpo'},
                'mago': {'name': 'Mago', 'emoji': 'üîÆ', 'desc': 'Mestre das artes arcanas'},
                'sacerdote': {'name': 'Sacerdote', 'emoji': '‚ú®', 'desc': 'Curandeiro e suporte'}
            }
            
            for row in cursor.fetchall():
                class_name = row[0]
                if class_name in class_descriptions:
                    classes.append({
                        'table': class_name,
                        'name': class_descriptions[class_name]['name'],
                        'emoji': class_descriptions[class_name]['emoji'],
                        'description': class_descriptions[class_name]['desc']
                    })
            
            cursor.close()
            return classes
            
        except Exception as e:
            print(f"‚ùå Erro ao buscar classes: {e}")
            return []

    def create_player_character(self, name: str, character_class: str) -> bool:
        """Cria um novo personagem jogador"""
        try:
            cursor = self.connection.cursor()
            
            # Stats baseados na classe
            class_stats = {
                'guerreiro': {'vida': 150, 'mana': 80, 'habilidade': 'Combate Corpo a Corpo', 'resistencia': 'F√≠sico'},
                'mago': {'vida': 90, 'mana': 200, 'habilidade': 'Feiti√ßaria Arcana', 'resistencia': 'Fogo'},
                'arqueiro': {'vida': 110, 'mana': 120, 'habilidade': 'Tiro Certeiro', 'resistencia': 'Ar'},
                'sacerdote': {'vida': 120, 'mana': 180, 'habilidade': 'Cura Divina', 'resistencia': 'Luz'}
            }
            
            stats = class_stats.get(character_class, class_stats['guerreiro'])
            
            # Inserir personagem
            cursor.execute("""
                INSERT INTO personagem (nome, vida_maxima, mana_maxima, habilidade, dificuldade, level, resistencia, dialogo)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s) RETURNING ID_personagem
            """, (name, stats['vida'], stats['mana'], stats['habilidade'], 'Normal', 1, stats['resistencia'], f"Sou {name}, um {character_class} da Terra M√©dia!"))
            
            player_id = cursor.fetchone()[0]
            
            # Inserir jogador com cen√°rio inicial
            cursor.execute("""
                INSERT INTO jogador (ID_personagem, cenario, tipo_equipamento)
                VALUES (%s, %s, %s)
            """, (player_id, 1, "Equipamento B√°sico"))
            
            # Inserir skills baseadas na classe
            class_attack = {
                'guerreiro': 70, 'mago': 55, 'arqueiro': 65, 'sacerdote': 45
            }
            
            cursor.execute("""
                INSERT INTO skill (ID_jogador, atq) VALUES (%s, %s)
            """, (player_id, class_attack.get(character_class, 50)))
            
            # Inserir caracter√≠sticas elementais baseadas na classe
            elemental_stats = {
                'guerreiro': {'fogo': 20, 'agua': 20, 'terra': 40, 'ar': 20},
                'mago': {'fogo': 50, 'agua': 30, 'terra': 10, 'ar': 30},
                'arqueiro': {'fogo': 25, 'agua': 25, 'terra': 25, 'ar': 45},
                'sacerdote': {'fogo': 35, 'agua': 35, 'terra': 35, 'ar': 15}
            }
            
            stats_elem = elemental_stats.get(character_class, elemental_stats['guerreiro'])
            cursor.execute("""
                INSERT INTO caracteristicas (ID_jogador, fogo, agua, terra, ar)
                VALUES (%s, %s, %s, %s, %s)
            """, (player_id, stats_elem['fogo'], stats_elem['agua'], stats_elem['terra'], stats_elem['ar']))
            
            # Inserir na tabela da classe espec√≠fica
            if character_class == "guerreiro":
                cursor.execute("""
                    INSERT INTO guerreiro (id_personagem, atq_Fisico, bloquear_Dano)
                    VALUES (%s, %s, %s)
                """, (player_id, 80, 60))
            elif character_class == "mago":
                cursor.execute("""
                    INSERT INTO mago (id_personagem, atq_Magico, atq_MultiElemento)
                    VALUES (%s, %s, %s)
                """, (player_id, 90, 70))
            elif character_class == "arqueiro":
                cursor.execute("""
                    INSERT INTO arqueiro (id_personagem, atq_Preciso, atq_Rapido)
                    VALUES (%s, %s, %s)
                """, (player_id, 85, 75))
            elif character_class == "sacerdote":
                cursor.execute("""
                    INSERT INTO sacerdote (id_personagem, bencao_Cura, atq_Especial)
                    VALUES (%s, %s, %s)
                """, (player_id, 95, 40))
            
            # Criar invent√°rio inicial
            cursor.execute("""
                INSERT INTO inventario (id_personagem, pods) VALUES (%s, %s) RETURNING id_inventario
            """, (player_id, 100))
            
            inv_id = cursor.fetchone()[0]
            
            # Adicionar item inicial + moedas
            initial_items = {
                'guerreiro': ('Espada de Ferro', 2.5, 100),
                'mago': ('Cajado M√°gico', 1.5, 80),
                'arqueiro': ('Arco √âlfico', 2.0, 90),
                'sacerdote': ('Bast√£o Sagrado', 1.8, 85)
            }
            
            item_name, peso, durabilidade = initial_items.get(character_class, initial_items['guerreiro'])
            cursor.execute("""
                INSERT INTO item (nome, peso, durabilidade, id_inventario) VALUES (%s, %s, %s, %s)
            """, (item_name, peso, durabilidade, inv_id))
            
            # Adicionar 10 moedas iniciais (cada uma como item separado)
            for _ in range(10):
                cursor.execute("""
                    INSERT INTO item (nome, peso, durabilidade, id_inventario) VALUES (%s, %s, %s, %s)
                """, ("Moeda de Ouro", 0.01, 999, inv_id))
            
            self.connection.commit()
            self.current_player_id = player_id
            self.current_scenario_id = 1
            
            print(f"üéâ {name} o {character_class} desperta no Condado!")
            print("üìú Uma nova jornada √©pica come√ßa...")
            return True
            
        except Exception as e:
            print(f"‚ùå Erro ao criar personagem: {e}")
            self.connection.rollback()
            return False
        finally:
            cursor.close()

    def get_player_stats(self) -> Optional[Dict[str, Any]]:
        """Obt√©m stats completos do jogador"""
        try:
            cursor = self.connection.cursor()
            cursor.execute("""
                SELECT p.nome, p.vida_maxima, p.mana_maxima, p.level, p.habilidade, 
                       p.resistencia, j.tipo_equipamento, j.cenario, s.atq, c.fogo, c.agua, c.terra, c.ar,
                       CASE 
                         WHEN EXISTS(SELECT 1 FROM guerreiro g WHERE g.id_personagem = p.ID_personagem) THEN 'Guerreiro'
                         WHEN EXISTS(SELECT 1 FROM mago m WHERE m.id_personagem = p.ID_personagem) THEN 'Mago'
                         WHEN EXISTS(SELECT 1 FROM arqueiro a WHERE a.id_personagem = p.ID_personagem) THEN 'Arqueiro'
                         WHEN EXISTS(SELECT 1 FROM sacerdote s WHERE s.id_personagem = p.ID_personagem) THEN 'Sacerdote'
                         ELSE 'Desconhecida'
                       END as classe
                FROM personagem p
                JOIN jogador j ON p.ID_personagem = j.ID_personagem
                LEFT JOIN skill s ON j.ID_personagem = s.ID_jogador
                LEFT JOIN caracteristicas c ON j.ID_personagem = c.ID_jogador
                WHERE p.ID_personagem = %s
            """, (self.current_player_id,))
            
            result = cursor.fetchone()
            if result:
                # Atualizar cen√°rio atual do jogador na mem√≥ria
                self.current_scenario_id = result[7]
                return {
                    "nome": result[0], "vida": result[1], "mana": result[2], "level": result[3],
                    "habilidade": result[4], "resistencia": result[5], "equipamento": result[6],
                    "cenario": result[7], "ataque": result[8], "fogo": result[9], "agua": result[10], 
                    "terra": result[11], "ar": result[12], "classe": result[13]
                }
            return None
        except Exception as e:
            print(f"‚ùå Erro ao obter stats do jogador: {e}")
            return None
        finally:
            cursor.close()

    def get_scenario_info(self, scenario_id: int) -> Optional[Dict[str, Any]]:
        """Obt√©m informa√ß√µes detalhadas do cen√°rio"""
        try:
            cursor = self.connection.cursor()
            cursor.execute("""
                SELECT id_cenario, sol, chuva, noite, dia, norte_id, leste_id, oeste_id, sul_id
                FROM cenario WHERE id_cenario = %s
            """, (scenario_id,))
            
            result = cursor.fetchone()
            if result:
                return {
                    "id": result[0], "sol": result[1], "chuva": result[2], "noite": result[3],
                    "dia": result[4], "norte": result[5], "leste": result[6], 
                    "oeste": result[7], "sul": result[8]
                }
            return None
        except Exception as e:
            print(f"‚ùå Erro ao obter informa√ß√µes do cen√°rio: {e}")
            return None
        finally:
            cursor.close()

    def get_scenario_descriptions(self) -> Dict[int, str]:
        """Descri√ß√µes imersivas dos cen√°rios"""
        return {
            1: "üèûÔ∏è **O Condado** - Campos verdejantes se estendem at√© onde a vista alcan√ßa. Hobbits trabalham pacificamente em suas fazendas.",
            2: "üå≤ **Floresta Sombria** - √Årvores anci√£s sussurram segredos sombrios. Galhos retorcidos bloqueiam a luz do sol.",
            3: "‚õ∞Ô∏è **Montanhas Nebulosas** - Picos nevados perfuram as nuvens. O vento frio corta como l√¢minas de gelo.",
            4: "üè∞ **Ru√≠nas de Osgiliath** - Pedras ancestrais contam hist√≥rias de gl√≥ria e destrui√ß√£o. Ecos do passado ressoam pelos corredores vazios.",
            5: "üíÄ **P√¢ntano dos Mortos** - Uma n√©voa densa cobre √°guas paradas. Vozes sussurram entre as sombras e luzes fantasmag√≥ricas flutuam sobre o brejo.",
            6: "‚õèÔ∏è **Minas de Moria** - T√∫neis escuros e ecoantes, repletos de antigas ru√≠nas an√£s e perigos ocultos nas profundezas.",
            7: "üå¨Ô∏è **Colinas do Vento** - Gramados altos e ventos constantes. O horizonte se estende sem fim sob um c√©u aberto.",
            8: "‚öì **Porto Cinzento** - O mar encontra a Terra M√©dia em um porto antigo, onde navios √©lficos partem para o Oeste. O ar √© salgado e cheio de esperan√ßa."
        }

    def get_random_creatures_for_scenario(self, scenario_id: int) -> List[Tuple[int, str, int, int]]:
        """Retorna criaturas espec√≠ficas do cen√°rio, exceto as j√° derrotadas"""
        try:
            cursor = self.connection.cursor()
            
            # Buscar criaturas espec√≠ficas do cen√°rio, exceto as j√° derrotadas
            cursor.execute("""
                SELECT c.ID_personagem, p.nome, p.vida_maxima, c.XP
                FROM criatura c
                JOIN personagem p ON c.ID_personagem = p.ID_personagem
                JOIN cenario_criatura cc ON c.ID_personagem = cc.id_personagem
                WHERE cc.id_cenario = %s 
                AND c.ID_personagem NOT IN (
                    SELECT id_criatura FROM criaturas_derrotadas WHERE id_jogador = %s
                )
                ORDER BY RANDOM()
                LIMIT 2
            """, (scenario_id, self.current_player_id))
            
            creatures = cursor.fetchall()
            cursor.close()
            
            # Se n√£o h√° criaturas dispon√≠veis, retornar lista vazia
            if not creatures:
                return []
            
            # Retornar 1-2 criaturas aleat√≥rias
            return random.sample(creatures, min(2, len(creatures)))
            
        except Exception as e:
            print(f"‚ùå Erro ao buscar criaturas: {e}")
            return []

    def mark_creature_defeated(self, creature_id: int):
        """Marca uma criatura como derrotada no banco de dados"""
        try:
            cursor = self.connection.cursor()
            cursor.execute("""
                INSERT INTO criaturas_derrotadas (id_jogador, id_criatura)
                VALUES (%s, %s)
                ON CONFLICT (id_jogador, id_criatura) DO NOTHING
            """, (self.current_player_id, creature_id))
            self.connection.commit()
            cursor.close()
        except Exception as e:
            print(f"‚ùå Erro ao marcar criatura como derrotada: {e}")
            self.connection.rollback()

    def get_player_money(self) -> int:
        """Conta o dinheiro do jogador - CORRIGIDO E ROBUSTO"""
        try:
            if not self.current_player_id:
                print("‚ö†Ô∏è current_player_id √© None")
                return 0
            cursor = self.connection.cursor()
            # Query robusta: apenas Moeda de Ouro, INNER JOIN
            cursor.execute("""
                SELECT COUNT(i.id_item) as money_count
                FROM inventario inv
                INNER JOIN item i ON inv.id_inventario = i.id_inventario
                WHERE inv.id_personagem = %s AND i.nome = 'Moeda de Ouro'
            """, (self.current_player_id,))
            result = cursor.fetchone()
            cursor.close()
            if result and len(result) > 0 and result[0] is not None:
                return int(result[0])
            else:
                print("Tupla vazia ou None")
                return 0
        except Exception as e:
            print(f"‚ùå Erro ao contar dinheiro: {e}")
            return 0

    def update_quest_progress(self, quest_type: str, increment: int = 1):
        """Atualiza progresso de quests baseado no tipo de a√ß√£o"""
        quest_mapping = {
            'npc_talk': 2,      # Defensor do Condado (conversas com NPCs)
            'creature_kill': 2,  # Defensor do Condado (3 criaturas)
            'explore': 3,        # Explorador da Terra M√©dia (4 cen√°rios)
            'trade': 4,          # Ca√ßador de Goblins (transa√ß√µes)
            'palantir_fragment': 1  # A Busca do Palant√≠r (3 fragmentos)
        }
        
        quest_id = quest_mapping.get(quest_type)
        if not quest_id:
            return
            
        try:
            cursor = self.connection.cursor()
            
            # Verificar se jogador tem a quest ativa
            cursor.execute("""
                SELECT progresso_atual, progresso_maximo FROM quest_progresso
                WHERE id_jogador = %s AND id_quest = %s AND status = 'Em Progresso'
            """, (self.current_player_id, quest_id))
            
            result = cursor.fetchone()
            if result:
                atual, maximo = result
                novo_progresso = min(atual + increment, maximo)
                
                cursor.execute("""
                    UPDATE quest_progresso 
                    SET progresso_atual = %s
                    WHERE id_jogador = %s AND id_quest = %s AND status = 'Em Progresso'
                """, (novo_progresso, self.current_player_id, quest_id))
                
                # Verificar se completou
                if novo_progresso >= maximo:
                    self.complete_quest(quest_id)
                
                self.connection.commit()
            
            cursor.close()
            
        except Exception as e:
            print(f"‚ùå Erro ao atualizar quest: {e}")
            self.connection.rollback()

    def start_initial_quest(self):
        """Inicia apenas a primeira quest para novos jogadores"""
        try:
            cursor = self.connection.cursor()
            
            # Verificar se j√° tem quest inicial
            cursor.execute("""
                SELECT COUNT(*) FROM quest_progresso WHERE id_jogador = %s
            """, (self.current_player_id,))
            
            if cursor.fetchone()[0] == 0:
                # Iniciar quest do Palant√≠r
                cursor.execute("""
                    INSERT INTO quest_progresso (id_jogador, id_quest, progresso_atual, progresso_maximo, status)
                    VALUES (%s, %s, %s, %s, %s)
                """, (self.current_player_id, 1, 0, 3, 'Em Progresso'))  # 3 fragmentos
                
                # Iniciar quest de defesa
                cursor.execute("""
                    INSERT INTO quest_progresso (id_jogador, id_quest, progresso_atual, progresso_maximo, status)
                    VALUES (%s, %s, %s, %s, %s)
                """, (self.current_player_id, 2, 0, 5, 'Em Progresso'))  # 5 criaturas
                
                self.connection.commit()
            
            cursor.close()
            
        except Exception as e:
            print(f"‚ùå Erro ao iniciar quest inicial: {e}")
            self.connection.rollback()

    def complete_quest(self, quest_id: int):
        """Completa uma quest e d√° recompensas"""
        try:
            cursor = self.connection.cursor()
            
            # Buscar dados da quest
            cursor.execute("""
                SELECT nome, recompensa_xp, recompensa_item FROM quest WHERE id_quest = %s
            """, (quest_id,))
            
            quest_data = cursor.fetchone()
            if quest_data:
                nome, xp_reward, item_reward = quest_data
                
                # Marcar como completada
                cursor.execute("""
                    UPDATE quest_progresso 
                    SET status = 'Completada'
                    WHERE id_jogador = %s AND id_quest = %s
                """, (self.current_player_id, quest_id))
                
                print(f"\nüéâ QUEST COMPLETADA: {nome}")
                
                # Dar XP
                if xp_reward > 0:
                    print(f"‚ú® Voc√™ ganhou {xp_reward} XP!")
                    
                    # Level up simples (500 XP por level)
                    current_level = self.get_player_stats()['level']
                    new_level = current_level + (xp_reward // 500)
                    
                    if new_level > current_level:
                        cursor.execute("""
                            UPDATE personagem SET level = %s WHERE ID_personagem = %s
                        """, (new_level, self.current_player_id))
                        print(f"üÜô Voc√™ subiu para o n√≠vel {new_level}!")
                
                # Dar item de recompensa
                if item_reward:
                    cursor.execute("""
                        SELECT id_inventario FROM inventario WHERE id_personagem = %s
                    """, (self.current_player_id,))
                    
                    inv_id = cursor.fetchone()[0]
                    cursor.execute("""
                        INSERT INTO item (nome, peso, durabilidade, id_inventario)
                        VALUES (%s, %s, %s, %s)
                    """, (item_reward, 0.5, 999, inv_id))
                    
                    print(f"üéÅ Voc√™ recebeu: {item_reward}")
                
                # Iniciar pr√≥xima quest automaticamente se for principal
                if quest_id == 1:  # Ap√≥s quest do Palant√≠r, iniciar explorador
                    cursor.execute("""
                        INSERT INTO quest_progresso (id_jogador, id_quest, progresso_atual, progresso_maximo, status)
                        VALUES (%s, %s, %s, %s, %s)
                        ON CONFLICT (id_jogador, id_quest) DO NOTHING
                    """, (self.current_player_id, 3, 0, 4, 'Em Progresso'))  # 4 cen√°rios
                elif quest_id == 2:  # Ap√≥s quest de defesa, iniciar ca√ßador de goblins
                    cursor.execute("""
                        INSERT INTO quest_progresso (id_jogador, id_quest, progresso_atual, progresso_maximo, status)
                        VALUES (%s, %s, %s, %s, %s)
                        ON CONFLICT (id_jogador, id_quest) DO NOTHING
                    """, (self.current_player_id, 4, 0, 3, 'Em Progresso'))  # 3 goblins
                
                self.connection.commit()
            
            cursor.close()
            
        except Exception as e:
            print(f"‚ùå Erro ao completar quest: {e}")
            self.connection.rollback()

    def move_player(self, direction: str) -> bool:
        """Sistema de movimento que salva no banco"""
        try:
            scenario = self.get_scenario_info(self.current_scenario_id)
            if not scenario:
                return False
            
            direction_map = {
                "norte": scenario["norte"], "sul": scenario["sul"],
                "leste": scenario["leste"], "oeste": scenario["oeste"]
            }
            
            new_scenario_id = direction_map.get(direction.lower())
            if new_scenario_id is None:
                print("üö´ N√£o h√° caminho nessa dire√ß√£o!")
                time.sleep(1.5)
                return False
            
            # Anima√ß√£o de movimento
            direction_emoji = {"norte": "üîº", "sul": "üîΩ", "leste": "‚ñ∂Ô∏è", "oeste": "‚óÄÔ∏è"}
            
            print(f"\n{direction_emoji.get(direction, 'üö∂')} Voc√™ caminha para o {direction}...")
            for i in range(3):
                print("." * (i + 1))
                time.sleep(0.5)
            
            # Atualizar cen√°rio no banco
            cursor = self.connection.cursor()
            cursor.execute("""
                UPDATE jogador SET cenario = %s WHERE ID_personagem = %s
            """, (new_scenario_id, self.current_player_id))
            
            self.connection.commit()
            self.current_scenario_id = new_scenario_id
            
            # Descri√ß√£o da chegada
            descriptions = self.get_scenario_descriptions()
            new_description = descriptions.get(new_scenario_id, f"Regi√£o #{new_scenario_id}")
            print(f"\nüìç {new_description}")
            
            # Atualizar quest de explora√ß√£o
            self.update_quest_progress('explore', 1)
            
            cursor.close()
            return True
            
        except Exception as e:
            print(f"‚ùå Erro ao mover jogador: {e}")
            self.connection.rollback()
            return False

    def battle_creature(self, creature_id: int, creature_name: str, creature_hp: int, creature_xp: int):
        """Sistema de combate melhorado"""
        try:
            player_stats = self.get_player_stats()
            if not player_stats:
                return False
                
            player_attack = player_stats['ataque']
            player_hp = player_stats['vida']
            
            print(f"\n‚öîÔ∏è **BATALHA √âPICA** ‚öîÔ∏è")
            print(f"üßô‚Äç‚ôÇÔ∏è {player_stats['nome']} VS {creature_name} üëπ")
            print("="*50)
            
            # Combate por turnos
            turn = 1
            while creature_hp > 0 and player_hp > 0:
                print(f"\nüîÑ Turno {turn}")
                print(f"üë§ Sua vida: {player_hp} | üëπ Vida do {creature_name}: {creature_hp}")
                
                print("\n1. ‚öîÔ∏è Ataque normal")
                print("2. üî• Ataque elemental")
                print("3. üõ°Ô∏è Defender")
                print("4. üèÉ Fugir")
                
                choice = input("\n‚û§ Sua a√ß√£o: ").strip()
                
                damage_reduction = 1.0
                
                if choice == "1":
                    # Ataque normal
                    damage = random.randint(player_attack - 10, player_attack + 10)
                    creature_hp -= damage
                    print(f"‚öîÔ∏è Voc√™ ataca causando {damage} de dano!")
                    
                elif choice == "2":
                    # Ataque elemental baseado na classe
                    elemental_bonus = max(player_stats['fogo'], player_stats['agua'], 
                                        player_stats['terra'], player_stats['ar'])
                    damage = random.randint(player_attack, player_attack + elemental_bonus)
                    creature_hp -= damage
                    print(f"üî• Ataque elemental! {damage} de dano!")
                    
                elif choice == "3":
                    # Defender
                    print("üõ°Ô∏è Voc√™ se prepara para se defender...")
                    damage_reduction = 0.5
                    
                elif choice == "4":
                    # Fugir
                    if random.random() < 0.7:
                        print("üèÉ Voc√™ conseguiu fugir da batalha!")
                        return False
                    else:
                        print("‚ùå N√£o conseguiu fugir!")
                
                # Turno da criatura
                if creature_hp > 0:
                    base_damage = random.randint(15, 25)
                    creature_damage = int(base_damage * damage_reduction)
                    
                    player_hp -= creature_damage
                    print(f"üëπ {creature_name} ataca causando {creature_damage} de dano!")
                
                turn += 1
                time.sleep(1.5)
            
            # Resultado da batalha
            victory = creature_hp <= 0
            
            # Registrar no banco
            cursor = self.connection.cursor()
            cursor.execute("""
                INSERT INTO batalha (Dano_causado, Controle_Dano, Ambiente_batalha, Dano_sofrido)
                VALUES (%s, %s, %s, %s)
            """, (player_attack, 100, f"Cen√°rio {self.current_scenario_id}", 
                  player_stats['vida'] - player_hp))
            
            cursor.execute("""
                INSERT INTO confronta (vencedor, criatura_id, jogador_id)
                VALUES (%s, %s, %s)
            """, (victory, creature_id, self.current_player_id))
            
            if victory:
                print(f"\nüéâ VIT√ìRIA! Voc√™ derrotou {creature_name}!")
                print(f"‚ú® Voc√™ ganhou {creature_xp} XP!")
                
                # Marcar criatura como derrotada
                self.mark_creature_defeated(creature_id)
                
                # Atualizar quest de combate
                self.update_quest_progress('creature_kill', 1)
                
                # Level up simples
                current_level = player_stats['level']
                if creature_xp >= 200:
                    new_level = current_level + 1
                    cursor.execute("""
                        UPDATE personagem SET level = %s WHERE ID_personagem = %s
                    """, (new_level, self.current_player_id))
                    print(f"üÜô Voc√™ subiu para o n√≠vel {new_level}!")
                
            else:
                print(f"\nüíÄ DERROTA! {creature_name} foi mais forte...")
                print("üè• Voc√™ foi transportado para um local seguro para se recuperar...")
            
            self.connection.commit()
            cursor.close()
            return victory
            
        except Exception as e:
            print(f"‚ùå Erro durante a batalha: {e}")
            self.connection.rollback()
            return False

    def search_for_items(self):
        """Procura por itens na √°rea atual, incluindo fragmentos do Palant√≠r"""
        print("\nüîç Voc√™ procura por itens perdidos...")
        time.sleep(2)
        
        # Chance de encontrar item
        if random.random() < 0.4:  # 40% de chance
            # Chance especial de encontrar fragmento do Palant√≠r (10%)
            if random.random() < 0.1:
                found_item = "Fragmento do Palant√≠r"
                print(f"‚ú® DESCOBERTA √âPICA! Voc√™ encontrou: {found_item}!")
                # Atualizar quest do Palant√≠r
                self.update_quest_progress('palantir_fragment', 1)
            else:
                # Itens normais aleat√≥rios
                scenario_items = [
                    "Erva Medicinal", "Moeda de Prata", "P√£o de Lemba", "Madeira √âlfica", 
                    "Cristal Sombrio", "Pele de Lobo", "Ferro das Montanhas", "Gema Congelada", 
                    "Osso de Drag√£o", "Fragmento Antigo", "Runa Perdida", "Pedra do Rei",
                    "Po√ß√£o de Cura", "Pergaminho Antigo", "Anel Simples"
                ]
                found_item = random.choice(scenario_items)
                print(f"üéÅ Voc√™ encontrou: {found_item}!")
            
            try:
                cursor = self.connection.cursor()
                
                # Buscar invent√°rio do jogador
                cursor.execute("""
                    SELECT id_inventario FROM inventario WHERE id_personagem = %s
                """, (self.current_player_id,))
                
                inv_id = cursor.fetchone()[0]
                
                # Adicionar item
                cursor.execute("""
                    INSERT INTO item (nome, peso, durabilidade, id_inventario)
                    VALUES (%s, %s, %s, %s)
                """, (found_item, 0.5, 100, inv_id))
                
                self.connection.commit()
                cursor.close()
                
            except Exception as e:
                print(f"‚ùå Erro ao adicionar item: {e}")
        else:
            print("ü§∑ Voc√™ n√£o encontrou nada de interessante...")
        
        time.sleep(2)

    def show_shop(self, merchant_name: str, sell_items: List[str], buy_items: List[str]):
        """Sistema de compra e venda implementado"""
        while True:
            self.clear_screen()
            print(f"üõí LOJA DE {merchant_name.upper()} üõí")
            print("="*50)
            
            # Mostrar dinheiro do jogador
            player_money = self.get_player_money()
            print(f"üí∞ Suas moedas: {player_money}")
            
            print("\n1. üõçÔ∏è Comprar itens")
            print("2. üí∞ Vender itens")
            print("3. üö∂ Sair da loja")
            
            choice = input("\n‚û§ O que deseja fazer? ").strip()
            
            if choice == "1":
                self.buy_menu(merchant_name, sell_items)
            elif choice == "2":
                self.sell_menu(merchant_name, buy_items)
            elif choice == "3":
                break
            else:
                print("‚ùì Op√ß√£o inv√°lida!")
                time.sleep(1)

    def buy_menu(self, merchant_name: str, available_items: List[str]):
        """Menu de compra"""
        item_prices = {
            "Po√ß√£o de Cura": 3,
            "Adaga de Ferro": 5,
            "Espada de Ferro": 10,
            "Armadura de Couro": 8,
            "Escudo de Madeira": 4,
            "Po√ß√£o de Mana": 3,
            "Anel de Prote√ß√£o": 15,
            "Po√ß√µes de cura": 3,
            "Adagas de ferro": 5
        }
        
        print(f"\nüõçÔ∏è {merchant_name}: \"Veja meus melhores itens:\"")
        print("-" * 40)
        
        player_money = self.get_player_money()
        
        for i, item in enumerate(available_items, 1):
            price = item_prices.get(item, 3)
            affordable = "‚úÖ" if player_money >= price else "‚ùå"
            print(f"{i}. {affordable} {item} - {price} moedas")
        
        print("0. Voltar")
        
        try:
            choice = int(input("\n‚û§ Qual item comprar? ").strip())
            if choice == 0:
                return
            elif 1 <= choice <= len(available_items):
                item = available_items[choice - 1]
                price = item_prices.get(item, 3)
                
                if player_money >= price:
                    self.purchase_item(item, price)
                    print(f"‚úÖ Voc√™ comprou {item} por {price} moedas!")
                    self.update_quest_progress('trade', 1)
                else:
                    print("‚ùå Dinheiro insuficiente!")
            else:
                print("‚ùì Op√ß√£o inv√°lida!")
        except ValueError:
            print("‚ùì Digite um n√∫mero v√°lido!")
        
        time.sleep(2)

    def sell_menu(self, merchant_name: str, wanted_items: List[str]):
        """Menu de venda"""
        try:
            cursor = self.connection.cursor()
            
            # Buscar itens do jogador (exceto moedas)
            cursor.execute("""
                SELECT i.id_item, i.nome FROM item i
                JOIN inventario inv ON i.id_inventario = inv.id_inventario
                WHERE inv.id_personagem = %s AND i.nome NOT LIKE '%Moeda%'
                ORDER BY i.nome
            """, (self.current_player_id,))
            
            player_items = cursor.fetchall()
            cursor.close()
            
            if not player_items:
                print("üéí Voc√™ n√£o tem itens para vender.")
                time.sleep(2)
                return
            
            print(f"\nüí∞ {merchant_name}: \"Estou interessado nestes itens:\"")
            print("-" * 40)
            
            sellable_items = []
            for item_id, nome in player_items:
                # O comerciante aceita qualquer item por um pre√ßo b√°sico
                sellable_items.append((item_id, nome))
            
            if not sellable_items:
                print("‚ùå Voc√™ n√£o tem nada que eu queira comprar.")
                time.sleep(2)
                return
            
            for i, (item_id, nome) in enumerate(sellable_items[:10], 1):  # Mostrar apenas 10 itens
                price = random.randint(1, 3)  # Pre√ßo de venda baixo
                print(f"{i}. {nome} - {price} moedas")
            
            print("0. Voltar")
            
            try:
                choice = int(input("\n‚û§ Qual item vender? ").strip())
                if choice == 0:
                    return
                elif 1 <= choice <= len(sellable_items):
                    item_id, nome = sellable_items[choice - 1]
                    price = random.randint(1, 3)
                    
                    self.sell_item(item_id, price)
                    print(f"‚úÖ Voc√™ vendeu {nome} por {price} moedas!")
                    self.update_quest_progress('trade', 1)
                else:
                    print("‚ùì Op√ß√£o inv√°lida!")
            except ValueError:
                print("‚ùì Digite um n√∫mero v√°lido!")
            
            time.sleep(2)
            
        except Exception as e:
            print(f"‚ùå Erro no menu de venda: {e}")

    def purchase_item(self, item_name: str, price: int):
        """Compra um item"""
        try:
            cursor = self.connection.cursor()

            # Buscar id_inventario ANTES de remover moedas
            cursor.execute("""
                SELECT id_inventario FROM inventario WHERE id_personagem = %s
            """, (self.current_player_id,))
            inv_row = cursor.fetchone()
            if not inv_row:
                print("‚ùå Invent√°rio n√£o encontrado para o jogador!")
                cursor.close()
                return
            inv_id = inv_row[0]

            # Verificar se h√° moedas suficientes
            cursor.execute("""
                SELECT COUNT(*) FROM item WHERE id_inventario = %s AND nome = 'Moeda de Ouro'
            """, (inv_id,))
            moedas = cursor.fetchone()[0]
            print(f"Moedas dispon√≠veis antes da compra: {moedas}")
            if moedas < price:
                print("‚ùå Dinheiro insuficiente para a compra!")
                cursor.close()
                return

            # Remover moedas (uma por vez at√© atingir o pre√ßo)
            for _ in range(price):
                cursor.execute("""
                    DELETE FROM item WHERE id_item IN (
                        SELECT id_item FROM item WHERE id_inventario = %s AND nome = 'Moeda de Ouro' LIMIT 1
                    )
                """, (inv_id,))

            # Adicionar item comprado
            cursor.execute("""
                INSERT INTO item (nome, peso, durabilidade, id_inventario)
                VALUES (%s, %s, %s, %s)
            """, (item_name, 1.0, 100, inv_id))

            self.connection.commit()
            print(f"Compra realizada: {item_name} por {price} moedas")
            cursor.close()

        except Exception as e:
            print(f"‚ùå Erro na compra: {e}")
            self.connection.rollback()

    def sell_item(self, item_id: int, price: int):
        """Vende um item"""
        try:
            cursor = self.connection.cursor()
            
            # Remover item
            cursor.execute("DELETE FROM item WHERE id_item = %s", (item_id,))
            
            # Adicionar moedas
            cursor.execute("""
                SELECT id_inventario FROM inventario WHERE id_personagem = %s
            """, (self.current_player_id,))
            
            inv_id = cursor.fetchone()[0]
            for _ in range(price):
                cursor.execute("""
                    INSERT INTO item (nome, peso, durabilidade, id_inventario)
                    VALUES (%s, %s, %s, %s)
                """, ("Moeda de Ouro", 0.01, 999, inv_id))
            
            self.connection.commit()
            cursor.close()
            
        except Exception as e:
            print(f"‚ùå Erro na venda: {e}")
            self.connection.rollback()

    def interact_with_npc(self, npc_id: int, npc_name: str, npc_type: str):
        """Intera√ß√£o aprimorada com NPCs"""
        self.clear_screen()
        print(f"üßô‚Äç‚ôÇÔ∏è CONVERSANDO COM {npc_name.upper()} üßô‚Äç‚ôÇÔ∏è")
        print("="*60)
        self.display_status()
        
        try:
            cursor = self.connection.cursor()
            
            # Buscar di√°logo
            cursor.execute("SELECT dialogo FROM personagem WHERE ID_personagem = %s", (npc_id,))
            dialog_result = cursor.fetchone()
            dialog = dialog_result[0] if dialog_result else "Ol√°, aventureiro!"
            
            print(f"\nüí¨ {npc_name}: \"{dialog}\"")
            
            if npc_type == "Guia":
                self.interact_with_guide(cursor, npc_id, npc_name)
            elif npc_type == "Comerciante":
                self.interact_with_merchant(cursor, npc_id, npc_name)
            elif npc_type == "NPC":
                self.interact_with_quest_npc(cursor, npc_id, npc_name)
            
            # Atualizar quest de conversa apenas para NPCs de quest (n√£o comerciantes)
            if npc_type == "NPC":
                cursor.execute("""
                    SELECT COUNT(*) FROM quest_progresso qp
                    WHERE qp.id_jogador = %s AND qp.id_quest = 1 
                    AND qp.progresso_atual < qp.progresso_maximo
                """, (self.current_player_id,))
                
                if cursor.fetchone()[0] > 0:
                    self.update_quest_progress('npc_talk', 1)
            
            cursor.close()
            
        except Exception as e:
            print(f"‚ùå Erro ao interagir com NPC: {e}")
            time.sleep(2)

    def interact_with_merchant(self, cursor, npc_id: int, npc_name: str):
        """Intera√ß√£o espec√≠fica com Comerciantes"""
        try:
            cursor.execute("""
                SELECT c.venda_item, c.compra_item FROM comerciante c WHERE c.ID_personagem = %s
            """, (npc_id,))
            
            result = cursor.fetchone()
            if result:
                venda_item, compra_item = result
                
                # Converter strings em listas
                sell_items = [item.strip() for item in venda_item.split(",")]
                buy_items = [item.strip() for item in compra_item.split(",")]
                
                print(f"\nüõí {npc_name}: \"Bem-vindo √† minha loja!\"")
                
                choice = input("\n‚û§ Deseja entrar na loja? (s/n): ").strip().lower()
                if choice in ['s', 'sim', 'y', 'yes']:
                    self.show_shop(npc_name, sell_items, buy_items)
                
        except Exception as e:
            print(f"‚ùå Erro na intera√ß√£o com comerciante: {e}")

    def interact_with_guide(self, cursor, npc_id: int, npc_name: str):
        """Intera√ß√£o espec√≠fica com Guias"""
        try:
            cursor.execute("""
                SELECT g.custo_orientacao FROM guia g WHERE g.ID_personagem = %s
            """, (npc_id,))
            
            result = cursor.fetchone()
            if result:
                custo = result[0]
                
                print(f"\nüó∫Ô∏è {npc_name} oferece orienta√ß√£o.")
                print("\n1. üß≠ Pedir mapa da regi√£o")
                print("2. üìç Perguntar sobre locais importantes") 
                print("3. ‚öîÔ∏è Pedir dicas de combate")
                print("4. üîÆ Perguntar sobre o Palant√≠r")
                print("5. üö∂ Despedir-se")
                
                choice = input("\n‚û§ O que voc√™ quer? ").strip()
                
                if choice == "1":
                    print(f"\n{npc_name}: \"Aqui est√° um mapa b√°sico da regi√£o...\"")
                    print("üìú Voc√™ recebeu conhecimento sobre os caminhos!")
                    
                elif choice == "2":
                    print(f"\n{npc_name}: \"Cuidado com as criaturas que vagam por a√≠...\"")
                    print("\"Elas podem aparecer em qualquer lugar da Terra M√©dia.\"")
                    
                elif choice == "3":
                    print(f"\n{npc_name}: \"Use seus ataques elementais sabiamente.\"")
                    print("\"Defender pode salvar sua vida em batalhas dif√≠ceis.\"")
                    
                elif choice == "4":
                    print(f"\n{npc_name}: \"Dizem que fragmentos do Palant√≠r est√£o espalhados...\"")
                    print("\"Procure bem ao explorar cada regi√£o. S√£o muito raros!\"")
                    
                elif choice == "5":
                    print(f"\n{npc_name}: \"Que os ventos guiem seus passos!\"")
                
                time.sleep(3)
        except Exception as e:
            print(f"‚ùå Erro na intera√ß√£o com guia: {e}")

    def interact_with_quest_npc(self, cursor, npc_id: int, npc_name: str):
        """Intera√ß√£o espec√≠fica com NPCs de Quest"""
        try:
            cursor.execute("""
                SELECT n.quest, n.localizacao FROM npc n WHERE n.ID_personagem = %s
            """, (npc_id,))
            
            result = cursor.fetchone()
            if result:
                quest_desc, localizacao = result
                
                if quest_desc:
                    print(f"\nüìú **MISS√ÉO ESPECIAL**")
                    print(f"üéØ {quest_desc}")
                    print(f"üìç Local: {localizacao}")
                    
                    print("\n1. ‚úÖ Aceitar informa√ß√µes")
                    print("2. ‚ùì Mais detalhes")
                    print("3. üö∂ Ir embora")
                    
                    choice = input("\n‚û§ Sua decis√£o: ").strip()
                    
                    if choice == "1":
                        print(f"\n{npc_name}: \"Excelente! A Terra M√©dia precisa de her√≥is como voc√™!\"")
                        print("üìù Informa√ß√µes valiosas obtidas!")
                        
                    elif choice == "2":
                        print(f"\n{npc_name}: \"Esta miss√£o testar√° sua coragem...\"")
                        print("\"Prepare-se bem antes de partir!\"")
                        
                    elif choice == "3":
                        print(f"\n{npc_name}: \"Pense na minha proposta. O destino pode depender disso.\"")
                else:
                    print(f"\n{npc_name}: \"Por enquanto n√£o tenho tarefas para voc√™.\"")
                    print("\"Mas continue sua jornada, her√≥i!\"")
                
                time.sleep(3)
        except Exception as e:
            print(f"‚ùå Erro na intera√ß√£o com NPC de quest: {e}")

    def explore_area(self):
        """Explora √°rea atual com criaturas aleat√≥rias"""
        self.clear_screen()
        print("üßô‚Äç‚ôÇÔ∏è SENHOR DOS AN√âIS - EXPLORA√á√ÉO üßô‚Äç‚ôÇÔ∏è")
        print("="*60)
        self.display_status()
        self.display_scenario()
        
        try:
            cursor = self.connection.cursor()
            
            print("\nüîç Voc√™ examina cuidadosamente a √°rea...")
            time.sleep(1.5)
            
            # Verificar NPCs espec√≠ficos do cen√°rio
            cursor.execute("""
                SELECT p.ID_personagem, p.nome, p.dialogo,
                       CASE 
                         WHEN EXISTS(SELECT 1 FROM guia g WHERE g.ID_personagem = p.ID_personagem) THEN 'Guia'
                         WHEN EXISTS(SELECT 1 FROM comerciante c WHERE c.ID_personagem = p.ID_personagem) THEN 'Comerciante'
                         WHEN EXISTS(SELECT 1 FROM npc n WHERE n.ID_personagem = p.ID_personagem) THEN 'NPC'
                         ELSE 'Pessoa'
                       END as tipo
                FROM personagem p
                JOIN cenario_npc cn ON p.ID_personagem = cn.id_personagem
                WHERE cn.id_cenario = %s
                AND p.ID_personagem IN (
                    SELECT ID_personagem FROM guia 
                    UNION 
                    SELECT ID_personagem FROM comerciante 
                    UNION 
                    SELECT ID_personagem FROM npc
                )
                ORDER BY RANDOM()
                LIMIT 3
            """, (self.current_scenario_id,))
            
            npcs = cursor.fetchall()
            
            # Verificar criaturas aleat√≥rias
            creatures = self.get_random_creatures_for_scenario(self.current_scenario_id)
            
            print("\nüé≠ **O QUE VOC√ä ENCONTRA:**")
            print("-" * 40)
            
            options = []
            option_num = 1
            
            # Adicionar NPCs
            if npcs:
                print("üë• Pessoas por aqui:")
                for npc in npcs:
                    npc_id, nome, dialogo, tipo = npc
                    print(f"  {option_num}. {tipo} {nome}")
                    options.append(('npc', npc))
                    option_num += 1
            
            # Adicionar criaturas
            if creatures:
                print("\nüëπ Criaturas avistadas:")
                for creature in creatures:
                    creature_id, nome, vida, xp = creature
                    print(f"  {option_num}. ‚öîÔ∏è Combater {nome} (Vida: {vida})")
                    options.append(('creature', creature))
                    option_num += 1
            
            # Op√ß√µes especiais
            print(f"\n{option_num}. üîç Procurar itens")
            options.append(('search', None))
            option_num += 1
            
            print(f"{option_num}. üìú Verificar miss√µes")
            options.append(('quests', None))
            option_num += 1
            
            print(f"{option_num}. üö∂ Voltar")
            options.append(('back', None))
            
            if not creatures:
                print("\nüëÄ N√£o h√° criaturas hostis nesta √°rea no momento.")
                print("   (Voc√™ pode conversar com os habitantes locais ou explorar)")
            
            try:
                choice = int(input(f"\n‚û§ O que deseja fazer? (1-{len(options)}): ").strip())
                if 1 <= choice <= len(options):
                    action_type, data = options[choice - 1]
                    
                    if action_type == 'npc':
                        self.interact_with_npc(data[0], data[1], data[3])
                    elif action_type == 'creature':
                        result = self.battle_creature(data[0], data[1], data[2], data[3])
                        time.sleep(2)
                    elif action_type == 'search':
                        self.search_for_items()
                    elif action_type == 'quests':
                        self.check_quests()
                        time.sleep(3)
                    elif action_type == 'back':
                        return
                else:
                    print("‚ùì Op√ß√£o inv√°lida!")
                    time.sleep(1)
            except ValueError:
                print("‚ùì Por favor, digite um n√∫mero v√°lido!")
                time.sleep(1)
            
            cursor.close()
            
        except Exception as e:
            print(f"‚ùå Erro ao explorar √°rea: {e}")
            time.sleep(2)

    def check_quests(self):
        """Verifica e exibe quests ativas do jogador"""
        try:
            cursor = self.connection.cursor()
            cursor.execute("""
                SELECT q.nome, q.descricao, qp.progresso_atual, qp.progresso_maximo, qp.status
                FROM quest_progresso qp
                JOIN quest q ON qp.id_quest = q.id_quest
                WHERE qp.id_jogador = %s AND qp.status = 'Em Progresso'
                ORDER BY q.tipo_quest, q.nome
            """, (self.current_player_id,))
            
            quests = cursor.fetchall()
            
            if quests:
                print("\nüìú **MISS√ïES ATIVAS**")
                print("-" * 50)
                for quest in quests:
                    nome, desc, atual, maximo, status = quest
                    progresso_bar = "‚ñà" * atual + "‚ñë" * (maximo - atual)
                    print(f"üéØ {nome}")
                    print(f"   {desc}")
                    print(f"   Progresso: [{progresso_bar}] {atual}/{maximo}")
                    print()
            else:
                print("\nüìú Nenhuma miss√£o ativa no momento.")
            
            cursor.close()
            
        except Exception as e:
            print(f"‚ùå Erro ao verificar quests: {e}")

    def display_scenario(self):
        """Exibe descri√ß√£o imersiva do cen√°rio atual"""
        scenario = self.get_scenario_info(self.current_scenario_id)
        if not scenario:
            return
        
        descriptions = self.get_scenario_descriptions()
        description = descriptions.get(scenario['id'], f"Regi√£o Desconhecida #{scenario['id']}")
        
        print("\n" + "="*70)
        print(description)
        print(f"üå§Ô∏è O dia est√° {scenario['dia']}, {scenario['sol']}")
        if scenario['chuva'] != 'Sem chuva':
            print(f"üåßÔ∏è {scenario['chuva']}")
        print("="*70)

    def display_status(self):
        """Exibe status detalhado do jogador"""
        player = self.get_player_stats()
        if player:
            money = self.get_player_money()
            print(f"\nüë§ **{player['nome']}** - {player['classe']} | N√≠vel {player['level']}")
            print(f"‚ù§Ô∏è Vida: {player['vida']} | üíô Mana: {player['mana']} | ‚öîÔ∏è Ataque: {player['ataque']} | üí∞ {money} moedas")
            print(f"üéØ {player['habilidade']} | üõ°Ô∏è Resist√™ncia: {player['resistencia']}")

    def show_inventory(self):
        """Sistema de invent√°rio aprimorado"""
        self.clear_screen()
        print("üßô‚Äç‚ôÇÔ∏è SENHOR DOS AN√âIS - INVENT√ÅRIO üßô‚Äç‚ôÇÔ∏è")
        print("="*60)
        self.display_status()
        
        try:
            cursor = self.connection.cursor()
            
            # Buscar invent√°rio completo
            cursor.execute("""
                SELECT i.pods, 
                       COALESCE(SUM(it.peso), 0) as peso_usado,
                       COUNT(it.id_item) as num_itens
                FROM inventario i
                LEFT JOIN item it ON i.id_inventario = it.id_inventario
                WHERE i.id_personagem = %s
                GROUP BY i.id_inventario, i.pods
            """, (self.current_player_id,))
            
            result = cursor.fetchone()
            if result:
                capacidade, peso_usado, num_itens = result
                
                print(f"\nüéí **INVENT√ÅRIO**")
                print(f"üì¶ Capacidade: {peso_usado:.1f}/{capacidade} kg utilizados")
                print(f"üìã Total de itens: {num_itens}")
                
                # Buscar itens agrupados
                cursor.execute("""
                    SELECT it.nome, it.peso, it.durabilidade, COUNT(*) as quantidade
                    FROM item it
                    JOIN inventario inv ON it.id_inventario = inv.id_inventario
                    WHERE inv.id_personagem = %s
                    GROUP BY it.nome, it.peso, it.durabilidade
                    ORDER BY it.nome
                """, (self.current_player_id,))
                
                itens = cursor.fetchall()
                
                if itens:
                    print("\nüìã **SEUS ITENS:**")
                    print("-" * 50)
                    for i, (nome, peso, durabilidade, quantidade) in enumerate(itens, 1):
                        durability_bar = "‚ñà" * (durabilidade // 20) + "‚ñë" * (5 - durabilidade // 20)
                        if quantidade > 1:
                            print(f"{i:2d}. {nome} x{quantidade}")
                        else:
                            print(f"{i:2d}. {nome}")
                        print(f"     ‚öñÔ∏è {peso}kg | üîß [{durability_bar}] {durabilidade}%")
                        print()
                else:
                    print("\nüì≠ Seu invent√°rio est√° vazio.")
            else:
                print("üéí Invent√°rio n√£o encontrado.")
            
            cursor.close()
            
        except Exception as e:
            print(f"‚ùå Erro ao mostrar invent√°rio: {e}")

    def show_navigation_options(self):
        """Menu de navega√ß√£o visual"""
        scenario = self.get_scenario_info(self.current_scenario_id)
        if not scenario:
            return False
        
        self.clear_screen()
        print("üßô‚Äç‚ôÇÔ∏è SENHOR DOS AN√âIS - NAVEGA√á√ÉO üßô‚Äç‚ôÇÔ∏è")
        print("="*70)
        self.display_status()
        self.display_scenario()
        
        print("\nüß≠ **MAPA LOCAL**")
        print("="*40)
        
        # Criar mapa visual simples
        directions = {
            'norte': scenario['norte'], 'sul': scenario['sul'],
            'leste': scenario['leste'], 'oeste': scenario['oeste']
        }
        
        # Norte
        north_symbol = "üîº" if directions['norte'] else "üö´"
        print(f"        {north_symbol}")
        print(f"        N")
        
        # Oeste - Centro - Leste
        west_symbol = "‚óÄÔ∏è" if directions['oeste'] else "üö´"
        east_symbol = "‚ñ∂Ô∏è" if directions['leste'] else "üö´"
        print(f"  {west_symbol} O   üèÉ YOU   L {east_symbol}")
        
        # Sul
        south_symbol = "üîΩ" if directions['sul'] else "üö´"
        print(f"        S")
        print(f"        {south_symbol}")
        
        print("\nüìç **DESTINOS DISPON√çVEIS:**")
        descriptions = self.get_scenario_descriptions()
        
        for direction, scenario_id in directions.items():
            if scenario_id:
                dest_desc = descriptions.get(scenario_id, f"√Årea {scenario_id}")
                direction_key = direction[0].upper()
                print(f"üó∫Ô∏è [{direction_key}] {direction.title()}: {dest_desc}")
        
        print("\nüîô [V] Voltar ao menu principal")
        print("="*40)
        
        return True

    def game_loop(self):
        """Loop principal do jogo"""
        # Iniciar quest inicial apenas uma vez
        self.start_initial_quest()
        
        # Mensagem de boas-vindas √©pica
        player_stats = self.get_player_stats()
        if player_stats:
            print("üßô‚Äç‚ôÇÔ∏è" + "="*68 + "üßô‚Äç‚ôÇÔ∏è")
            print("    üåü BEM-VINDO √Ä TERRA M√âDIA, BRAVE ADVENTURER! üåü")
            print(f"         {player_stats['nome']}, o {player_stats['classe']}")
            print("üßô‚Äç‚ôÇÔ∏è" + "="*68 + "üßô‚Äç‚ôÇÔ∏è")
            self.pause_and_clear("‚ö° Pressione Enter para come√ßar sua jornada √©pica...")
        
        while self.player_alive:
            self.clear_screen()
            print("üßô‚Äç‚ôÇÔ∏è LORD OF THE RINGS - TERRA M√âDIA üßô‚Äç‚ôÇÔ∏è")
            print("="*60)
            
            self.display_status()
            self.display_scenario()
            self.check_quests()
            
            print("\n‚öîÔ∏è **A√á√ïES √âPICAS DISPON√çVEIS:**")
            print("="*40)
            print("1. üö∂ Explorar e mover-se")
            print("2. üëÅÔ∏è Investigar √°rea")
            print("3. üéí Verificar invent√°rio")
            print("4. üìú Miss√µes ativas")
            print("5. üìä Status completo")
            print("6. üíæ Salvar progresso")
            print("7. üö™ Sair da aventura")
            
            choice = input("\n‚û§ Qual ser√° sua pr√≥xima a√ß√£o, her√≥i? ").strip().lower()
            
            if choice in ["1", "mover", "explorar"]:
                if self.show_navigation_options():
                    while True:
                        move_choice = input("\n‚û§ Para onde deseja ir? (n/s/l/o/v): ").strip().lower()
                        if move_choice == 'v':
                            break
                        elif move_choice in ['n', 's', 'l', 'o']:
                            direction_map = {'n': 'norte', 's': 'sul', 'l': 'leste', 'o': 'oeste'}
                            if self.move_player(direction_map[move_choice]):
                                time.sleep(2)
                            break
                        else:
                            print("‚ùì Comando inv√°lido! Use: n, s, l, o, v")
                            
            elif choice in ["2", "investigar", "area"]:
                self.explore_area()
                self.pause_and_clear()
                
            elif choice in ["3", "inventario", "invent√°rio"]:
                self.show_inventory()
                self.pause_and_clear()
                
            elif choice in ["4", "miss√µes", "missoes", "quests"]:
                self.clear_screen()
                print("üßô‚Äç‚ôÇÔ∏è SENHOR DOS AN√âIS - MISS√ïES üßô‚Äç‚ôÇÔ∏è")
                print("="*60)
                self.display_status()
                self.check_quests()
                self.pause_and_clear()
                
            elif choice in ["5", "status", "stats"]:
                self.show_detailed_stats()
                self.pause_and_clear()
                
            elif choice in ["6", "salvar"]:
                self.clear_screen()
                print("üíæ Salvando seu progresso √©pico...")
                time.sleep(1.5)
                print("‚úÖ Jogo salvo! Sua jornada est√° segura.")
                time.sleep(1.5)
                
            elif choice in ["7", "sair", "quit"]:
                self.clear_screen()
                print("üåü Sua jornada na Terra M√©dia foi lend√°ria!")
                print("üßô‚Äç‚ôÇÔ∏è \"Que a luz de E√§rendil brilhe em seu caminho...\"")
                print("\nüëã At√© a pr√≥xima aventura, nobre her√≥i!")
                break
                
            else:
                print("‚ùì Comando n√£o reconhecido. Tente novamente.")
                self.pause_and_clear("‚è∏Ô∏è Pressione Enter para continuar...")

    def show_detailed_stats(self):
        """Mostra estat√≠sticas detalhadas do jogador"""
        self.clear_screen()
        print("üßô‚Äç‚ôÇÔ∏è SENHOR DOS AN√âIS - STATUS COMPLETO üßô‚Äç‚ôÇÔ∏è")
        print("="*60)
        
        player = self.get_player_stats()
        if player:
            money = self.get_player_money()
            print(f"\nüëë **{player['nome'].upper()}**")
            print(f"üèõÔ∏è Classe: {player['classe']}")
            print(f"‚≠ê N√≠vel: {player['level']}")
            print(f"üí´ Habilidade Principal: {player['habilidade']}")
            print(f"üõ°Ô∏è Resist√™ncia: {player['resistencia']}")
            print(f"üí∞ Dinheiro: {money} moedas")
            
            print(f"\nüìä **ATRIBUTOS DE COMBATE:**")
            print(f"‚ù§Ô∏è Vida M√°xima: {player['vida']}")
            print(f"üíô Mana M√°xima: {player['mana']}")
            print(f"‚öîÔ∏è Poder de Ataque: {player['ataque']}")
            
            print(f"\nüîÆ **AFINIDADES ELEMENTAIS:**")
            print(f"üî• Fogo: {player['fogo']}")
            print(f"üíß √Ågua: {player['agua']}")
            print(f"üóø Terra: {player['terra']}")
            print(f"üí® Ar: {player['ar']}")
            
            # Mostrar hist√≥rico
            try:
                cursor = self.connection.cursor()
                cursor.execute("""
                    SELECT COUNT(*) as vitorias FROM confronta 
                    WHERE jogador_id = %s AND vencedor = TRUE
                """, (self.current_player_id,))
                
                vitorias = cursor.fetchone()[0]
                
                cursor.execute("""
                    SELECT COUNT(*) as derrotas FROM confronta 
                    WHERE jogador_id = %s AND vencedor = FALSE
                """, (self.current_player_id,))
                
                derrotas = cursor.fetchone()[0]
                
                cursor.execute("""
                    SELECT COUNT(*) as quests_completadas FROM quest_progresso
                    WHERE id_jogador = %s AND status = 'Completada'
                """, (self.current_player_id,))
                
                quests_completadas = cursor.fetchone()[0]
                
                print(f"\nüèÜ **HIST√ìRICO DE AVENTURAS:**")
                print(f"‚úÖ Vit√≥rias em Combate: {vitorias}")
                print(f"‚ùå Derrotas: {derrotas}")
                print(f"üìú Miss√µes Completadas: {quests_completadas}")
                cursor.execute("""
                    SELECT COUNT(*) as criaturas_derrotadas FROM criaturas_derrotadas
                    WHERE id_jogador = %s
                """, (self.current_player_id,))
                
                criaturas_derrotadas = cursor.fetchone()[0]
                print(f"üëπ Criaturas Derrotadas: {criaturas_derrotadas}")
                if vitorias + derrotas > 0:
                    win_rate = (vitorias / (vitorias + derrotas)) * 100
                    print(f"üìà Taxa de Vit√≥ria: {win_rate:.1f}%")
                
                cursor.close()
                
            except Exception as e:
                print(f"‚ùå Erro ao carregar hist√≥rico: {e}")

    def start_game(self):
        """Inicializa√ß√£o do jogo"""
        if not self.connect_database():
            return
        
        # Configurar sistema de quests
        self.setup_quest_system()
        
        self.clear_screen()
        
        print("üßô‚Äç‚ôÇÔ∏è" + "="*68 + "üßô‚Äç‚ôÇÔ∏è")
        print("              LORD OF THE RINGS")
        print("            TERMINAL MUD GAME")
        print("         üåü TERRA M√âDIA AWAITS üåü")
        print("üßô‚Äç‚ôÇÔ∏è" + "="*68 + "üßô‚Äç‚ôÇÔ∏è")
        
        print("\nüìú \"Em um buraco no ch√£o vivia um hobbit...\"")
        print("üåü \"Mas esta √© uma nova hist√≥ria, com um novo her√≥i...\"")
        print("\nüéÆ **OP√á√ïES DE JOGO:**")
        print("1. üÜï Forjar um novo her√≥i")
        print("2. üìÇ Continuar jornada existente")
        print("3. üö™ Sair")
        
        choice = input("\n‚û§ Escolha seu destino: ").strip()
        
        if choice == "1":
            self.create_new_character()
        elif choice == "2":
            self.load_existing_character()
        elif choice == "3":
            print("\nüëã Que os ventos o levem de volta quando estiver pronto!")
            return
        else:
            print("‚ùì Escolha inv√°lida!")
            self.pause_and_clear()
            self.start_game()

    def create_new_character(self):
        """Processo de cria√ß√£o de personagem"""
        self.clear_screen()
        print("üßô‚Äç‚ôÇÔ∏è FORJANDO UM NOVO HER√ìI üßô‚Äç‚ôÇÔ∏è")
        print("="*50)
        
        print("üìú \"Nos sal√µes de Mandos, uma nova alma desperta...\"")
        print("üåü \"Qual ser√° seu nome nesta terra?\"")
        
        name = input("\nüìù Nome do seu her√≥i: ").strip()
        if not name:
            print("‚ùå Um her√≥i precisa de um nome!")
            self.pause_and_clear()
            return self.create_new_character()
        
        # Buscar classes dispon√≠veis
        available_classes = self.get_available_classes()
        if not available_classes:
            print("‚ùå Nenhuma classe encontrada no banco de dados!")
            self.pause_and_clear()
            return
        
        self.clear_screen()
        print(f"üßô‚Äç‚ôÇÔ∏è BEM-VINDO, {name.upper()}! üßô‚Äç‚ôÇÔ∏è")
        print("="*50)
        print("üé≠ \"Escolha sua voca√ß√£o na Terra M√©dia...\"")
        print("\n‚öîÔ∏è **CLASSES DISPON√çVEIS:**")
        
        for i, class_info in enumerate(available_classes, 1):
            print(f"\n{i}. {class_info['emoji']} **{class_info['name']}**")
            print(f"   {class_info['description']}")
        
        try:
            class_choice = int(input(f"\n‚û§ Escolha sua classe (1-{len(available_classes)}): ").strip()) - 1
            if 0 <= class_choice < len(available_classes):
                selected_class = available_classes[class_choice]
                
                if self.create_player_character(name, selected_class['table']):
                    self.pause_and_clear("‚ö° Pressione Enter para come√ßar sua lenda...")
                    self.game_loop()
            else:
                print("‚ùå Classe inv√°lida!")
                self.pause_and_clear()
                self.create_new_character()
        except ValueError:
            print("‚ùå Por favor, digite um n√∫mero v√°lido!")
            self.pause_and_clear()
            self.create_new_character()

    def load_existing_character(self):
        """Carregamento de personagem existente"""
        self.clear_screen()
        print("üßô‚Äç‚ôÇÔ∏è JORNADAS EXISTENTES üßô‚Äç‚ôÇÔ∏è")
        print("="*40)
        
        # Listar personagens existentes
        existing_players = self.list_existing_players()
        if not existing_players:
            print("üì≠ Nenhuma jornada anterior encontrada!")
            print("üÜï Talvez seja hora de come√ßar uma nova aventura...")
            self.pause_and_clear()
            return self.start_game()
        
        print("üìú \"Estas almas j√° caminharam pela Terra M√©dia...\"")
        print("\nüèÜ **HER√ìIS DISPON√çVEIS:**")
        
        for i, player in enumerate(existing_players, 1):
            print(f"\n{i}. üë§ **{player['nome']}**")
            print(f"   ‚öîÔ∏è {player['classe']} | ‚≠ê N√≠vel {player['level']}")
            print(f"   üéØ {player['habilidade']}")
            print(f"   üèÜ {player['vitorias']} vit√≥rias")
        
        try:
            player_choice = int(input(f"\n‚û§ Escolha seu her√≥i (1-{len(existing_players)}): ").strip()) - 1
            if 0 <= player_choice < len(existing_players):
                selected_player = existing_players[player_choice]['nome']
                
                if self.load_existing_player(selected_player):
                    self.pause_and_clear("‚ö° Pressione Enter para continuar sua lenda...")
                    self.game_loop()
            else:
                print("‚ùå Her√≥i inv√°lido!")
                self.pause_and_clear()
                self.load_existing_character()
        except ValueError:
            print("‚ùå Por favor, digite um n√∫mero v√°lido!")
            self.pause_and_clear()
            self.load_existing_character()

    def list_existing_players(self) -> List[Dict[str, Any]]:
        """Lista personagens jogadores existentes"""
        try:
            cursor = self.connection.cursor()
            cursor.execute("""
                SELECT p.nome, p.level, p.habilidade, 
                       CASE 
                         WHEN EXISTS(SELECT 1 FROM guerreiro g WHERE g.id_personagem = p.ID_personagem) THEN 'Guerreiro'
                         WHEN EXISTS(SELECT 1 FROM mago m WHERE m.id_personagem = p.ID_personagem) THEN 'Mago'
                         WHEN EXISTS(SELECT 1 FROM arqueiro a WHERE a.id_personagem = p.ID_personagem) THEN 'Arqueiro'
                         WHEN EXISTS(SELECT 1 FROM sacerdote s WHERE s.id_personagem = p.ID_personagem) THEN 'Sacerdote'
                         ELSE 'Desconhecida'
                       END as classe,
                       (SELECT COUNT(*) FROM confronta c WHERE c.jogador_id = p.ID_personagem AND c.vencedor = TRUE) as vitorias
                FROM personagem p
                JOIN jogador j ON p.ID_personagem = j.ID_personagem
                ORDER BY p.level DESC, p.nome
            """)
            
            players = []
            for row in cursor.fetchall():
                players.append({
                    'nome': row[0], 'level': row[1], 'habilidade': row[2],
                    'classe': row[3], 'vitorias': row[4]
                })
            
            cursor.close()
            return players
            
        except Exception as e:
            print(f"‚ùå Erro ao listar personagens: {e}")
            return []

    def load_existing_player(self, player_name: str) -> bool:
        """Carrega um personagem existente"""
        try:
            cursor = self.connection.cursor()
            cursor.execute("""
                SELECT p.ID_personagem, j.cenario
                FROM personagem p
                JOIN jogador j ON p.ID_personagem = j.ID_personagem
                WHERE LOWER(p.nome) = LOWER(%s)
                LIMIT 1
            """, (player_name,))
            
            result = cursor.fetchone()
            if result:
                self.current_player_id = result[0]
                self.current_scenario_id = result[1]
                cursor.close()
                return True
            else:
                print(f"‚ùå Her√≥i '{player_name}' n√£o encontrado!")
                cursor.close()
                return False
                
        except Exception as e:
            print(f"‚ùå Erro ao carregar her√≥i: {e}")
            return False

def main():
    """Fun√ß√£o principal com tratamento de erros √©pico"""
    print("üåü Inicializando a Terra M√©dia...")
    time.sleep(1)
    
    game = LordOfTheRingsMUD()
    try:
        game.start_game()
    except KeyboardInterrupt:
        game.clear_screen()
        print("\nüßô‚Äç‚ôÇÔ∏è \"Mesmo os menores podem mudar o curso do futuro...\"")
        print("üëã Sua jornada foi interrompida, mas a Terra M√©dia o aguarda!")
        print("‚ú® At√© nossa pr√≥xima aventura, nobre her√≥i!")
    except Exception as e:
        game.clear_screen()
        print(f"\nüíÄ Um poder sombrio causou um erro inesperado:")
        print(f"üîç {e}")
        print("üßô‚Äç‚ôÇÔ∏è \"Nem mesmo Gandalf pode prever todos os caminhos...\"")
        print("üîÑ Tente reiniciar sua jornada!")
    finally:
        if game.connection:
            game.connection.close()
            print("üîí Conex√£o com os registros da Terra M√©dia encerrada.")

if __name__ == "__main__":
    main()